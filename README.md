Link of the project: https://enchanting-gecko-48e3f2.netlify.app/


•	Have a look at your API endpoints. Think about what data you have available, and how you will structure your application. What routes will your application have? What articles will you choose to display on the main page?
API Available: 
- GET /api
- GET /api/topics
- GET /api/articles
- GET /api/articles/:article_id
- PATCH /api/articles/:article_id/comments
- GET /api/articles/:article_id/comments
- POST /api/articles/:article_id/comments
- DELETE /api/comments/:comment_id
- GET /api/users

Data Available: 
- Topics 
- Articles 
- Comments
- Users

Structure of application: 
See attached photo

Route available: 
Users can access via address bar: 
- / --> a home page 
- /topics -->  show all topics in a list 
- /Articles --> show all articles in a list
- /Articles/:article_id --> show the selected article

Routes can be used by functionality: 
- /articles/:article_id/comments -->  show/post comments under the selected article
- /comments/:comment_id -->  delete specific comments 
- /users --> ‘authentication’ to check if the user has the right to post/delete comments


•	What articles to display on the main page: 
-	Navigations to articles & Topics
•	Think how you will isolate the concerns of your project - the structure of your components, the sourcing of your data, the styling.
Structure of components:
- See attached photo. Each component will be created an individual jsx file to achieve the functionality.


Sourcing of data: 
- Data will come from API. 
- Only change data on API when it is needed and authorised. For example, GET method for showing data from API. However, it has to been authorised when involving PATCH/DELETE. 


Styling: 
- Components having the same functionality on the different pages can have the same styling (e.g. header & footer)
- Specific component will have its own classname with own styling to isolate problems if happens


•	What sort of routing will your app use? What sort of specificity do you think you will need? Remember, your URLs don't have to directly correspond to your API endpoints, but they will provide some guidance.
Use Route, Routes, BrowserRouter from "react-router-dom"
Each route to display to users will be created a page. Each page will be routed in app with BrowserRouter
For example: 
        	   <Route path='/' element = {<Home />} />
                <Route path='/topics' element={<TopicsPage />} />
                <Route path='/articles' element ={<ArticlesPage/>} />
                <Route path='/articles/:articleId' element ={<ArticlePage/>} />

•	Think about what data each component will need. Where will it come from? When should components find their own data and when should they load it themselves? Focus on the simplest functionality first.

-	Header: set in jsx file 
-	Nav: set in jsx file 
-	TopicList: API
-	TopicCard: API
-	ArticleList: API
-	ArticleCard: API
-	CommentList : API
-	CommentCard : API
-	Comment Patcher: user
-	Comment Adder: user 
-	Comment Deleter: delete from API 
-	Footer: set in jsx file


•	Authentication is something we do not have on our back end. You should hardcode a logged-in user.

•	Consider more complex functionality: how do you want to allow changes to your database? Think about how you will attribute users to posted comments etc. How will you know what comments/articles a user should be allowed to delete? How about sorting data, or paginating responses? A good starting point would be to pick a single user and assume that all new articles and comments are being posted by that user.
- Comment Patcher: User can give likes to comments they like. That will send patch to API to change database

How do you want to allow changes to your database: 
- Comment Adder: Anyone can add a comment by POST
- Comment Patcher: Anyone can send likes by PATCH
- Comment Deleter: only people who posted the comment can DELETE the comments 

How you will attribute users to posted comments:
-	Users can use comment adder (a form) to POST their comments to the API

How will you know what comments/articles a user should be allowed to delete: 
-	User can only delete things when it was created by themselves. An “authenticator” will check if the username is matching

How about sorting data, or paginating responses: 
-	Comment id is generated by backend SQL automatically 
-	Current sorting is using default values, customed sort by is not available due to advanced tasks in BE project branches haven’t merged yet. Once all core tasks of this project has been finished, this will be added later. 

•	How are you going to make this a fluid and engaging experience for users so they want to come back for more?
-	Make sure the website is well designed and consider accessibility requirements 
-	Potentially create a “mail list” subscription function (if all cores tasks are finished) 
